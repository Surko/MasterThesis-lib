package genlib.initializators;

import genlib.evolution.individuals.TreeIndividual;
import genlib.generators.Generator;
import genlib.generators.TreeGenerator;
import genlib.locales.TextKeys;
import genlib.locales.TextResource;
import genlib.structures.Data;
import genlib.utils.Utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.logging.Logger;

/**
 * TreePopulationInitializator interface that is implemented by classes which
 * are supposed to make starting population of tree individuals for an
 * evolutionary algorithm. This interface is not dependent on any library
 * (weka,...) so it can be implemented in either way what current project
 * actually uses. Initialization is done by calling {@link #initPopulation()}
 * and it generates individuals in a form of Individual object. That's because
 * in some cases of population initializators we can compute fitness function of
 * these generated individuals right as they are created. Fill the population
 * pool is then only matter of copying individuals with their apropriate
 * fitness. It eases up the computation because otherwise we should have to
 * first compute fitness (test instances) after calling initPopulation (that
 * itself traverse the tree and tests instances) and then copying.
 * 
 * @author Lukas Surin
 * @see Generator
 */
public abstract class TreePopulationInitializator implements
		PopulationInitializator<TreeIndividual> {

	/**
	 * Enum with possible parameters
	 * 
	 * @author Lukas Surin
	 *
	 */
	enum PopInitEnum {
		RESAMPLE, AUTOHEIGHT, DIVIDEPARAM, MAXHEIGHT, DATA;

		public static PopInitEnum value(String name) {
			if (RESAMPLE.name().equals(name)) {
				return RESAMPLE;
			}
			if (AUTOHEIGHT.name().equals(name)) {
				return AUTOHEIGHT;
			}
			if (DIVIDEPARAM.name().equals(name)) {
				return DIVIDEPARAM;
			}
			if (MAXHEIGHT.name().equals(name)) {
				return MAXHEIGHT;
			}
			if (DATA.name().equals(name)) {
				return DATA;
			}

			return null;
		}
	}

	/** for serialization */
	private static final long serialVersionUID = 7222530982342870829L;
	/** logger */
	private static final Logger LOG = Logger
			.getLogger(TreePopulationInitializator.class.getName());
	/** depth of generated trees. */
	protected int maxHeight = 1;
	/** number of division of trainin data */
	protected int divideParam = 10;
	/** only resampling instead of dividing */
	protected boolean resample = true;
	/** recounting of depth inside trees */
	protected boolean autoHeight = false;
	/** Individuals that makes this population */
	protected TreeIndividual[] population;
	/** Number of threads that will be creating population */
	protected int nThreads;

	/**
	 * Generator of tree population. It contains all of the generated trees that
	 * are used to combine.
	 */
	protected TreeGenerator gen;
	/**
	 * Random seeded object for this run of algorithm. Default from Utils. Can
	 * be changed.
	 */
	protected Random random;
	/** Object ({@link Data}) of all instances */
	protected Data data;
	/** Final population size */
	protected int popSize;
	/** type of data split used in creating population */
	protected int typeOfData = -1;

	/**
	 * Method that returns population of generated individuals from
	 * TreeGenerator.
	 */
	public TreeIndividual[] getPopulation() {
		return population;
	}

	/**
	 * Method that returns individuals that are generated by generators without
	 * any further processing.
	 * 
	 * @return origin population
	 */
	@Override
	public TreeIndividual[] getOriginPopulation() {
		return gen.getIndividuals();
	}

	/**
	 * Gets the depth of the combined trees (population trees) from generated
	 * trees.
	 * 
	 * @return Depth of the trees in population.
	 */
	public int getMaxHeight() {
		return maxHeight;
	}

	/**
	 * Method returns how many times is the data set divided and used to
	 * generate individuals.
	 * 
	 * @return divide parameter
	 */
	public int getDivideParam() {
		return divideParam;
	}

	/**
	 * Method tests if the generated trees should compute the height
	 * automatically
	 * 
	 * @return true iff height is computed automatically
	 */
	public boolean getAutoHeight() {
		return autoHeight;
	}

	/**
	 * Method gets the generator used to generate individuals that are further
	 * initialized
	 * 
	 * @return TreeGenerator
	 */
	@Override
	public TreeGenerator getGenerator() {
		return gen;
	}

	/**
	 * Method returns attrvalueIndexMap with mapping of attribute values onto
	 * indeces
	 * 
	 * @return hashmaps with mapping
	 */
	public HashMap<String, Integer>[] getAttrValueIndexMap() {
		return data.getAttrValueIndexMap();
	}

	/**
	 * Method returns attrIndexMap with mapping of attribute onto indeces
	 * 
	 * @return hasmap with mapping
	 */
	public HashMap<String, Integer> getAttrIndexMap() {
		return data.getAttrIndexMap();
	}

	/**
	 * Method returns if the data set is resampled when generating individuals
	 * 
	 * @return true iff dataset will be resampled
	 */
	public boolean isResampling() {
		return resample;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getPopulationSize() {
		return popSize;
	}

	/**
	 * {@inheritDoc}
	 */
	public void setRandomGenerator(Random random) {
		this.random = random;
	}

	/**
	 * Method sets the maximal depth of initialized trees.
	 * 
	 * @param depth
	 *            of trees
	 */
	public void setDepth(int depth) {
		this.maxHeight = depth;
	}

	/**
	 * Method sets how many times is the data set divided and used to generate
	 * individuals.
	 * 
	 * @param divideParam
	 */
	public void setDivideParam(int divideParam) {
		this.divideParam = divideParam;
	}

	/**
	 * Method sets if the data used to initialize should be resampled.
	 * 
	 * @param resample
	 */
	public void setResample(boolean resample) {
		this.resample = resample;
	}

	/**
	 * Method sets if the generated trees should compute the height
	 * automatically
	 */
	public void setAutoDepth(boolean autoDepth) {
		this.autoHeight = autoDepth;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setGenerator(ArrayList<? extends Generator<TreeIndividual>> gen) {
		if (gen.size() > 0) {
			this.gen = (TreeGenerator) gen.get(0);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setData(Data data) {
		this.data = data.getDataOfType(typeOfData);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setPopulationSize(int popSize) {
		this.popSize = popSize;
	}

	/**
	 * Set the number of threads used to initialize population
	 * 
	 * @param nThreads
	 *            number of threads
	 */
	public void setNumOfThreads(int nThreads) {
		this.nThreads = nThreads;
	}

	/**
	 * {@inheritDoc}
	 */
	public void setParam(String param) {
		String[] params = param.split(Utils.pDELIM);

		for (int i = 0; i < params.length; i += 2) {
			PopInitEnum popInitEnum = PopInitEnum.value(params[i]);

			if (popInitEnum == null) {
				LOG.warning(String.format(
						TextResource.getString(TextKeys.iExcessParam),
						params[i]));
				continue;
			}

			switch (popInitEnum) {
			case AUTOHEIGHT:
				this.autoHeight = Boolean.parseBoolean(params[i + 1]);
				break;
			case DIVIDEPARAM:
				this.divideParam = Integer.parseInt(params[i + 1]);
				break;
			case MAXHEIGHT:
				this.maxHeight = Integer.parseInt(params[i + 1]);
				break;
			case RESAMPLE:
				this.resample = Boolean.parseBoolean(params[i + 1]);
				break;
			case DATA:
				this.typeOfData = Integer.parseInt(params[i + 1]);
				break;
			default:
				break;
			}

		}
	}

}
